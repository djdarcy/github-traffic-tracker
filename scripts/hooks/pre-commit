#!/bin/sh
# Pre-commit hook that:
# 1. Updates version.py with correct version info
# 2. Prevents committing private content to public branches

# Get current branch name
current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")

# Get the repository root
REPO_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"

# Change to repository root for script execution
cd "$REPO_ROOT" 2>/dev/null || true

# PART 1: Sync all version files (Two-Phase Process)
# ---------------------------------------------------
# Pre-commit: Updates version strings with current git metadata, auto-stages
# Post-commit: Updates with actual commit hash (leaves unstaged for next commit)
SYNC_SCRIPT="$REPO_ROOT/scripts/sync-versions.py"
if [ -f "$SYNC_SCRIPT" ]; then
    # Run in auto mode ‚Äî quiet, stages files, uses today's date
    UPDATE_OUTPUT=$(python "$SYNC_SCRIPT" --auto 2>&1)
    UPDATE_EXIT=$?

    if [ $UPDATE_EXIT -eq 0 ]; then
        # Stage all version files to ensure they're included in this commit
        git add version.py src/ghtraf/_version.py 2>/dev/null
        # Stage alias toml only if it exists and changed
        if [ -f "packages/ghtraf-alias/pyproject.toml" ]; then
            git add packages/ghtraf-alias/pyproject.toml 2>/dev/null
        fi
        echo "‚úì Version synced and staged for commit"
    else
        echo "‚ö† Warning: Version sync failed but continuing"
    fi
fi

# PART 2: Check for private content (from RepoKit)
# -------------------------------------------------
# Define private branches where private content is allowed
case "$current_branch" in
    local|private|feature/*|feat/*|prototype/*|experiment/*|spike/*)
        echo "Checking for private content on branch: $current_branch"
        exit 0
        ;;
    main|dev|live|test|production|staging|prod|master)
        echo "üîç RepoKit Pre-Commit Check"
        echo "   Branch: $current_branch (public)"
        ;;
    *)
        echo "üîç RepoKit Pre-Commit Check"
        echo "   Branch: $current_branch (public)"
        ;;
esac

# Check for private content using BranchContext patterns
has_private_content=0
for file in $(git diff --cached --name-only); do
    # Check against all private content patterns from BranchContext
    if echo "$file" | grep -q -E "^.*/__private__.*|^.*/private_.*|^.*\..*~$|^.*\.backup$|^.*\.bak$|^.*\.log$|^.*\.tmp$|^.*~$|^\.env.*|^\.env\.local$|^\.env\.private$|^\.repokit\.json$|^CLAUDE\.md$|^Clipboard Text.*|^convos/|^credentials/|^logs/|^logs/.*|^logs/.*/.*|^nul$|^private/|^private/claude/|^private/docs/|^private/notes/|^private/temp/|^revisions/|^revisions/.*|^revisions/.*/.*|^secrets/|^test-runs/|^test_runs/"; then
        if [ $has_private_content -eq 0 ]; then
            echo ""
            echo "‚ùå COMMIT BLOCKED - Private Content Protection"
            echo ""
            echo "ERROR: Attempting to commit private files to public branch '$current_branch':"
            echo ""
            has_private_content=1
        fi
        echo "  - $file"
    fi
done

if [ $has_private_content -eq 1 ]; then
    echo ""
    echo "These files should only exist in private branches."
    echo "To fix this:"
    echo "  1. Switch to private branch: git checkout private"
    echo "  2. Or unstage these files: git reset HEAD <file>"
    echo "  3. Or remove from working directory: rm <file>"
    echo ""
    exit 1
fi

# Check for large files (>10MB)
for file in $(git diff --cached --name-only); do
    if [ -f "$file" ]; then
        size=$(du -k "$file" | awk '{print $1}')
        if [ "$size" -gt 10240 ]; then
            echo "ERROR: File $file is too large ($size KB)"
            echo "Consider using Git LFS or add to .gitignore"
            exit 1
        fi
    fi
done

exit 0